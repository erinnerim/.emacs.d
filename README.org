* Introduction to Emacs
  Emacs is a general-purpose text editor and programming environment [[[https://faculty.iiit.ac.in/~venkatesh.choppella/popl/current-topics/literate-programming/index.html][1]]]. It is popularly described on [[https://www.reddit.com/r/emacs/][reddit.com/r/emacs]] as "The extensible, customizable, self-documenting real-time display editor". Decades old and favored by notable old-school developers, emacs' attention over its long lifespan leaves it well-supported and applicable to software development, academic writing, and virtually any sort of text-based technical work. As an Integrated Desktop Environment (IDE), emacs may be ideal for backward-compatible, language-agnostic programming work based entirely in free software.
[[./emacs_geometry.png]]
** Summary of Comparison with Other IDEs (Opinion)
   In contrast with other popular free-software text-editors such as vim and nano, emacs tends toward a more featureful and maximalistic approach. Relative to these, emacs' source code is not particularly lean, its base functionality is arcane and unintuitive, and out-of-the-box is completely unusable. However, once properly configured it should encounter negligible performance issues, and its interface is as transparent and intuitive as one configures it to be.
   With respect to proprietary software like VSCode, emacs clearly excels. Customizability of these proprietary programs is usually fraught with obscure challenges: the codebase is opaque and often large, and there is always risk for the loss of support (I used VSCode for several years before emacs).
   I believe for developers it is worth the time investment and configuration hassle to properly implement emacs, especially when used as a daily driver. My emacs configuration runs smoothly on decades-old hardware; with the proper application of keybindings, ergonomic efficiency and speed do become asymptotically optimal.
* Dotfiles Introduction
  There are so many personal customizations possible in emacs, so that they are completely unique to the individual. This one focuses on the role of IDE for multi-lingual software development, augmented with agenda and note-taking functionality for daily convenience and administration. This configuration contains many functional, stylistic, and ergonomic tweaks, which are recommended to change to one's personal preference.
  Emacs is written in a dialect of lisp called emacs-lisp, or elisp. The code-blocks in ~myinit.org~ are the driving code for emacs configuration, and are marked up with plaintext comments and organizational structure using a feature of emacs called ~org-mode~, in the style of so-called [[https://faculty.iiit.ac.in/~venkatesh.choppella/popl/current-topics/literate-programming/index.html][literate programming]]. As such, these files are usable as-is by means of ~org-babel~ functionality included inside emacs; these example files should be sufficient to reproduce a working emacs build, which is enough to provide new users of emacs with a legible and featureful starting point for personal customization.
* Structure of Dotfiles
  Attached below is an example ~init.el~ file. When placed in one's emacs [[https://www.emacswiki.org/emacs/LoadPath][load-path]], upon running emacs or an [[https://www.emacswiki.org/emacs/EmacsAsDaemon][emacs daemon]] this init file will generate a new ~myinit.el~ configuration file from the accompanying ~myinit.org~ by way of a process called "tangling". This resulting ~myinit.el~ is what emacs interprets for its configuration.
* Installation
  This configuration uses emacs version 27.2. This is *not* the default version which is installed by running ~sudo apt install emacs~. Some features of this configuration break when using the default version. To ensure all features work, follow the steps in [[./Emacs_27.2_Installation.html]]. If there is an existing emacs configuration on the system, ensure it is completely removed prior to installation by following the *Uninstallation* instructions in the same document.
** Dotfiles
   Make a backup of ~~/.emacs.d~ directory and clear all files from it. Copy the ~myinit.org~ and ~myinit.el~ to the root of ~~/.emacs.d/~ directory. Run the command ~emacs --fg-daemon --debug-init~ in a terminal. Ensure internet access during this step for package installation. If all goes well, the terminal will output "~Starting Emacs Daemon~". Execute ~emacsclient -cn -s~ in another terminal to run emacs.
*** Optional: Org-Roam
    [[https://www.orgroam.com/][Org-Roam]] is a note-taking database-management package for maintaining a personal wiki. To enable it, create a directory for Org-Roam Notes and its subfolders (this configuration names ~~/Notes~). Change the variable ~org-roam-directory~ in ~myinit.org~ to point to the new directory. Customize the Templates in the Org-Roam subheader according to your needs and preference.
* Customization
*** Installation of packages
**** Package Repositories
     Many popular packages are found on the public repository known as [[https://melpa.org/][MELPA]]. After loading the line ~(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))~ of ~myinit.org~, packages from this repository will be available for view via ~M-x list-packages~. This is usually the simplest way to find new packages, as emacs will maintain available package documentation locally.
**** Use-Package Usage
     This configuration uses a meta-package called ~use-package~ to simplify package installation, which maintains easy portability and organization. Package-installation code snippets of ~myinit.org~ follow the basic template ~(use-package <package> :ensure t)~. This alone is sufficient to ensure package installation; I recommended to do it this way when modifying these dotfiles to maintain reproducibility, rather than clicking 'Install' through ~M-x list-package~.
* Feature Highlights
  Features of common use to software developers:
** Text Editing and Navigation
   Consult and customize the ~GLOBAL KEYBINDINGS->Text Navigation~ section of ~myinit.org~. 
*** Text Selection and Copy/Paste
    Use ~M-SPC~ or ~C-SPC~ to ~mark~ text, then move the ~point~ (text cursor) to highlight/select a region of text. This configuration rebinds to the common ~C-S-c~ copy, ~C-S-v~ paste/yank, and ~C-S-x~ cut/kill commands, which apply to such regions. By default, emacs uses ~M-w~, ~M-y~, and ~C-w~ respectively for these commands.
*** Rectangles
    The command prefix ~C-x r~ applies to rectangle editing commands, which operate on the rectangle formed with point and mark as corners: for example, ~C-x r t~ to multi-replace text in a rectangle, ~C-x r M-w~ and ~C-x r y~ to copy and paste rectangles, respectively.
*** Navigation (with [[https://github.com/abo-abo/avy][Avy]])
   Use ~M-p~ to perform ~avy-goto-char~, jumping the cursor to a visible text point based on character input. Avy is also used to jump to visible lines with ~M-/~. ~M-g g~ performs ~goto-line~, navigating around the entire buffer by line number. Use the ~swiper~ command (~C-s~ or ~M-;~) for a dynamic fuzzy-search minibuffer. Use ~M-[jl]~ and ~M-S-[jl]~ to navigate text by word or character, respectively; ~M-[ik]~ to navigate up/ and down lines, ~M-S-[ik]~ to move lines. Use ~C-[ijkl]~ to move to a window directionally, ~C-S-[ijkl]~ to move buffers between windows; ~M-S-/~ and ~C-S-/~ are the ace-jump counterparts to these respective movements.
   In org-mode and language modes, the ~M-[~, ~M-]~, ~M-{~ and ~M-}~ keybindings emulate a header/function navigation paradigm.
*** Multicursor and Find-Replace
    The package ~multiple-cursors~ gives familiar IDE multi-cursor editing capability. Use ~C-M-,~ and ~C-M-.~ to mark previous and next occurrences of a selected region, respectively, with a duplicate cursor. Use ~C-M-/~ (~ace-mc-add-multiple-cursors~) for ace-using interactive char-candidate selection.
** View and workspace
   Emacs tabs are really an implementation of a workspace-management system. In this configuration, ~C-+~ creates a new tab and offers "fullscreen-toggle"; toggle back with ~C--~ (~tab-bar-close-tab~). The control-curly braces navigate between "tabs"/workspaces: ~C-{~ and ~C-}~.
   Emacs operates on a system of buffers. To see a list of all running buffers, use ~M-x ibuffer~ (~C-x C-b~). This list is sorted by buffer type using regular expressions on the buffer names; customize the list by changing the ~PACKAGES->Ibuffer~ section of ~myinit.org~.
** System Administration
*** Emacs Terminals
    There are a few different choices for terminal buffers inside emacs. They each have their strengths and flaws.
**** Eshell
     Included in emacs, eshell has nice features that integrate well with the rest of emacs, such as scrollback, editing, and navigating with support for the usual keybindings. This is to say, eshell buffers are fully editable and navigable. However, eshell has the drawback of disallowing certain character combinations common to bash; in particular, it does not support bash-style subshells, since these make use of the same parenthetical markers in which eshell is written. For this reason, eshell is unsuitable for execution of most nontrivial scripts. Despite this, eshell is still an excellent choice for most terminal commands. In this configuration, the command for a new eshell terminal buffer is bound to ~M-e~.
**** Multi-Term
     Although Term-Mode is included within emacs, the MELPA package [[https://www.emacswiki.org/emacs/MultiTerm][multi-term]] simplifies term-mode buffer management. Term-mode is a fully-functional terminal, and it is perfectly usable for running bash scripts, unlike Eshell. One drawback, however, is that usual terminal keybindings such as ~C-c~, or the ~C-a~ ~screen~ prefix, are not picked up by term-mode, rather emacs. However, repeating ~C-c C-c~ sends the cancel command to term-mode. Tab completion works, but is rebound here to ~M-<tab>~. The command for a new multi-term buffer is bound to ~M-E~ in this configuration.
**** Emacs No-Window
     Emacs may also be run similarly to nano inside a terminal. Use the command ~emacs -nw~ (or ~emacsclient -c -nw~ when running emacs as a daemon). Most features run like you would expect in this form, but keybindings are sometimes lost, i.e. clobbered by the hosting terminal.
*** Tramp
    Tramp is a way to view and modify remote files. This is very common for use in network-testing setup with multiple systems. In ~find-file~ (or ~counsel-find-file~ with ~C-x C-v~), simply append:
    ~/ssh::user@host:~/~ to the beginning of the file prompt. Emacs will prompt for password (once per session) and/or ssh-key exchange will be handled automatically. To edit files as root over the network, use ~C-x C-v~ with ~/ssh:you@remotehost|sudo:oracle@remotehost:/path/to/file~. With effective use of local caching, this tool is workable even over VPN. However, a break in the network will cause emacs to freeze and can result in loss of data from other buffers or processes. I recommend to create a second named daemon when initiating network file management by executing the command ~emacs --fg-daemon=remote~, then new emacs client instances can be initiated with ~emacsclient -cn -s remote~; this mitigates the effects of network outage vulnerability.
*** Editing Files with Root Privileges
    Similar to remote editing, simply append ~/sudo::/~ to the beginning of any ~find-file~ (or ~counsel-find-file~) query. All changes to that buffer will then be executed as root. Navigation with Dired from this buffer will maintain root privileges, creating more ~sudo~ buffers, so it is not necessary to run the same ~find-file /sudo::/~ command very often.
*** Dired and Async
    Dired is a directory navigator and editor for files. To initiate Dired mode, use the same command for ~counsel-find-file~, here bound to ~C-x C-v~, but with the name of a directory rather than a file. In Dired mode, mark files to be modified with ~m~, then perform various operations such as ~mv~, ~cp~, ~rm~ with the keys ~m~, ~C~, ~R~, respectively. Use ~Z~ to zip or unzip file archives. Use ~C-x C-q~ to enter Editable Dired Mode, then use any typical emacs commands in the dired buffer to rename or delete files, then save changes with ~C-x C-s~. In this configuration, use ~M-,~ and ~M-.~ to navigate up and down the directory structure, respectively. For copying or syncing large files or backups, use ~Y~ or ~M-x ora-dired-rsync~. Use ~w~ to copy the path at point or marked. Use ~M-w~ to copy the file path of the current buffer (this also works for files).
** Code Development and Maintenance
*** Compilation Buffer
    Of particular use to developers is the compile command, which in this configuration is bound to ~C-x e~. A popup window with linked compilation errors appears.
*** Grep Buffer
    The grep buffer is accessible via ~M-x lgrep~. It generates a navigable list of linked references to grep output, eliminating the need to switch to a terminal while editing in a project directory.
*** Magit
    This is a low-level GUI for git with logs, status buffer and quick keybindings. It offers a self-evident visual aid to git management. Magit is available in emacs by default. It is accessible via the keybinding ~C-x g~.
** Technical Writing
*** Org-Babel Tangle
    This is one feature for testing small code fragments. With org-mode enabled, create a code block enclosed in the form ~#+BEGIN_SRC~ <language> ~#+END_SRC~. Then ~C-c '~ to edit in the specified language mode, and ~C-c C-c~ executes the code block. These code blocks can be manipulated for a variety of output formats and specializations, even linking remote references of code blocks to one another. This lends itself the ability to display and execute code from multiple languages in the same document. Integration with Org-Tables allows for dynamic spreadsheets programmable in any language. Additionally, the ~M-x org-babel-tangle~ command (~C-c C-v t~) combines multiple code blocks to generate executable scripts.
    The Org-Transclude package dynamically incorporates [[https://en.wikipedia.org/wiki/Transclusion][occurences]] of text from another file into a org-file. Transclusions also work as fully executable code blocks. For example, write ~#+transclude: [[./hello.sh]] :src bash~ in an org file, then on that line execute ~C-c C-c~. More information is found at [[https://github.com/nobiot/org-transclusion][github.com/nobiot/org-transclusion]].
*** Org-Export
    An org file may export to several document types, including HTML, PDF, and LaTeX. To access the ~export-dispatcher~ from within an org buffer, execute ~C-c C-e~. A simple HTML export command is ~C-c C-e C-b C-a h o~ for Body-Only, Async-Export, HTML-export and open file. HTML exports maintain header hierarchy, images, links, tables, and code formatting.
